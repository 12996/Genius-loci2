# 地灵对话系统 - 归档机制方案对比

## 🤔 核心问题

**用户不主动结束会话时，如何保存对话？**

### 常见场景
1. 用户直接关闭浏览器窗口
2. 网络中断导致无法调用结束接口
3. 移动端按 Home 键退出应用
4. 用户切换到其他应用长时间不回来
5. 浏览器崩溃或系统崩溃

---

## 💡 三种归档机制对比

### 方案 1：纯超时机制（V2）

**原理：** 30分钟无操作后自动归档

```python
SESSION_TIMEOUT = 30 * 60  # 30分钟

async def _check_expired_sessions():
    while True:
        await asyncio.sleep(60)  # 每分钟检查
        # 检查并归档超时会话
```

**优点：**
- ✅ 简单易实现
- ✅ 不依赖用户行为
- ✅ 兜底保障

**缺点：**
- ❌ 占用内存太久（30分钟）
- ❌ 对话可能很长（消耗大量 Token）
- ❌ 服务重启会丢失会话

**适用场景：** 低频对话应用

---

### 方案 2：每轮对话立即归档（不推荐）

**原理：** 每次对话结束后立即归档

```python
async def chat():
    # 对话...
    await archive_conversation()  # 立即归档
```

**优点：**
- ✅ 不丢失任何对话
- ✅ 内存占用小

**缺点：**
- ❌ 频繁调用 AI 总结 API（成本高）
- ❌ 数据库写入频繁
- ❌ 用户体验差（每次都要等待总结）

**适用场景：** 无（不推荐）

---

### 方案 3：渐进式归档机制（V3，推荐）⭐

**原理：** 每N轮对话后自动归档并开启新会话

```python
AUTO_ARCHIVE_TURNS = 10  # 每10轮对话归档一次

async def chat():
    # 检查是否需要归档
    if current_turns % AUTO_ARCHIVE_TURNS == 0:
        # 归档当前会话
        await archive_conversation(...)
        # 创建新会话（继承上下文）
        new_session_id = create_session(...)
```

**流程示意：**

```
第1轮对话 → 第2轮 → ... → 第10轮
                        ↓
                   [自动归档]
                        ↓
                   [创建新会话]
                        ↓
第11轮对话 → 第12轮 → ... → 第20轮
                        ↓
                   [自动归档]
                        ↓
                   [创建新会话]
                        ↓
...（循环）
```

**优点：**
- ✅ **平衡内存和数据完整性**
- ✅ **对话不会太长（减少 Token 消耗）**
- ✅ **AI 总结成本可控**
- ✅ **用户体验流畅（无感知）**
- ✅ **保留超时机制作为兜底**

**缺点：**
- ⚠️ 会话切换时需要保持上下文连续性

**适用场景：** 高频对话应用（推荐）

---

## 🎯 最终推荐：混合机制（V3）

### 三层保障机制

```
┌─────────────────────────────────────────┐
│  第1层：用户主动结束（优先级最高）        │
│  - 点击"结束对话"按钮                     │
│  - 页面卸载事件（beforeunload）            │
│  - 立即归档 + 清除会话                    │
└─────────────────────────────────────────┘
                 ↓ (如果用户没有主动结束)
┌─────────────────────────────────────────┐
│  第2层：渐进式归档（自动执行）            │
│  - 每10轮对话自动归档                    │
│  - 创建新会话继续对话                     │
│  - 保持上下文连续性                       │
└─────────────────────────────────────────┘
                 ↓ (如果用户长时间不活跃)
┌─────────────────────────────────────────┐
│  第3层：超时归档（兜底保障）              │
│  - 30分钟无操作自动归档                  │
│  - 防止内存泄漏                          │
└─────────────────────────────────────────┘
```

### 配置参数

```python
# 渐进式归档配置
AUTO_ARCHIVE_TURNS = 10  # 每10轮对话归档一次

# 超时配置
SESSION_TIMEOUT = 30 * 60  # 30分钟
```

### 数据示例

#### genius_loci_record 表

```json
// 第1个会话（1-10轮对话）
{
  "id": 1,
  "bubble_id": 123,
  "ai_result": "{\"summary\": \"用户询问了天气，地灵推荐了附近的咖啡馆...\", \"turns\": 10}"
}

// 第2个会话（11-20轮对话）
{
  "id": 2,
  "bubble_id": 123,  // 同一个气泡
  "ai_result": "{\"summary\": \"用户继续询问咖啡馆的营业时间...\", \"turns\": 10}"
}

// 第3个会话（21-30轮对话）
{
  "id": 3,
  "bubble_id": 123,
  "ai_result": "{\"summary\": \"用户讨论了周末的活动计划...\", \"turns\": 10}"
}
```

#### 查询某个气泡的所有对话记录

```sql
SELECT
    id,
    ai_result,
    process_time
FROM genius_loci_record
WHERE bubble_id = 123
AND ai_process_type = 5  -- 对话总结
AND is_effective = 1
ORDER BY process_time ASC;
```

---

## 📊 性能对比

| 指标 | 纯超时 | 立即归档 | 渐进式归档 ⭐ |
|------|--------|----------|--------------|
| 内存占用 | 高（30分钟） | 低 | 中（可控） |
| AI 调用成本 | 低（1次） | 高（N次） | 中（N/10次） |
| 数据完整性 | 低（崩溃丢失） | 高 | 高 |
| 用户体验 | 一般 | 差 | 优秀 |
| 实现复杂度 | 简单 | 中等 | 中等 |

---

## 🚀 实施建议

### 推荐配置

```python
# 根据对话频率调整
AUTO_ARCHIVE_TURNS = 10  # 高频对话应用
AUTO_ARCHIVE_TURNS = 20  # 低频对话应用
SESSION_TIMEOUT = 30 * 60  # 30分钟
```

### 监控指标

1. **会话平均轮数**：调整 `AUTO_ARCHIVE_TURNS`
2. **AI 调用成本**：监控总结 API 调用次数
3. **内存占用**：监控活跃会话数
4. **数据丢失率**：超时未归档的会话比例

---

## ✅ 总结

### 最佳实践：渐进式归档机制

```
用户主动结束（最精确）
        ↓
渐进式归档（自动、平衡）
        ↓
超时归档（兜底）
```

### 核心优势

1. **数据完整性**：三层保障，不丢失对话
2. **成本可控**：减少不必要的 AI 调用
3. **用户体验**：无感知自动归档
4. **资源优化**：内存占用可控

---

**更新时间：** 2025-01-17
**推荐方案：** V3 渐进式归档机制 ⭐
